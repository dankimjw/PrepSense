# 5.2 Local Storage and Caching Strategy

1  Requirements summary

Aspect	Detail
Volume	≈10 000 recipes (single-user demo)
Per‑recipe fields	• JPEG/PNG image• Instructions (Markdown/HTML text)• Ingredients list (tokens + quantities)• Category tags• Allergen flags• 384‑D float32 embedding (≈1.5 kB/row)
Offline guarantee	Entire bundle pre‑downloaded; app must run with no network on iOS (Expo)
Query patterns	By ID, text search, category/allergen filters, top‑k cosine‑similar ingredients
Concurrency on the device	Up to ≈6 parallel React queries (list + detail + search) → <10 concurrent SQLite reads; writes are infrequent (updates only during bundle refresh)

Recipe images from Spoonacular average ≈150 kB (2 781 306 images ≈417 GB)  ￼, so 10 000 images ≈1.4 GB after download; down‑sampling to 512 px and WebP typically shrinks them to ~50 kB each (0.5 GB).

⸻

2  Local‑storage options

Option	Good	Caution	Fit for 10 k recipes
Chroma embedded (DuckDB + Parquet, in‑memory HNSW)	• 1‑line startup • Mature Python & TS clients• Fast ≤20 ms top‑k on 10 k×384 vectors  ￼	• Index held in RAM; requires ≈25 MB (vectors) + ≈15 MB (HNSW) for our set  ￼ • No official React Native build—needs WASM or Remote RPC	Possible: run in FastAPI only; client asks backend for similarity, or compile WASM (experimental)
Weaviate embedded	• Same API as cloud Weaviate• PQ/BQ compressions cut RAM 4‑32×  ￼	• Still >50 MB RSS for 10 k vectors; Go binary not supported inside Expo JS  ￼ ￼	Backend‑only
SQLite (FTS5)	• Built into iOS; expo‑sqlite wraps it• Instant list queries: 10 k rows load “almost instantaneous”  ￼ • JSON, BLOB columns, FTS5 virtual tables	• No native vector search; must store embeddings as blob and compute in JS or via extension	Primary structured store
WatermelonDB (RN ORM on SQLite)	• Observable queries; 53 ms latency for 1 000 gets; scales to 10 k rows  ￼	• Schema migrations in JS; no FTS5 yet	Good for reactive UI, wraps same SQLite file
Raw files + JSON sidecars	• Human‑readable; easy diff/patch• Streaming ZIP extract	• O(n) scans; no JOINs; syncing metadata ↔ images is fragile	Use inside bundle only for images and pre‑made embedding .npy

Conclusion for storage topology

SQLite (with FTS5) + image folder + optional Chroma inside FastAPI gives the best balance:
	•	One cross‑platform file (recipes.db) for Expo and backend
	•	Embedded full‑text search works offline
	•	The backend keeps a richer Chroma/HNSW index and streams top‑k back when local JS cosine search is too slow.

⸻

3  Caching & versioning Spoonacular

Layer	Technique	Key Points
Backend FastAPI	Central API key (demo) stored in .env; all Spoonacular calls funneled through /spoon/… endpoints. Each successful JSON + image response is persisted in a “cache” schema (SQLite or DuckDB) with etag, last_modified, and v<bundle> columns.	
Bundle creation	Nightly task (APScheduler, repeat_every) dumps: 1) recipes.db, 2) embeddings.npy, 3) /images/*.webp; zips as recipes_vYYYYMMDD.zip.	FastAPI background tasks reference:  ￼ ￼
HTTP re‑validation	On each API call backend sends If‑None‑Match; if 304, keeps local copy; else updates record and sets stale_at = now()+TTL (default 30 d).	
Invalidate on device	Expo checks /bundle/manifest.json (tiny) at app launch. If version > local, shows “Update available (50 MB)” prompt and downloads in background via expo-file-system resumeable download  ￼.	


⸻

4  Performance snapshot (iPhone 13 simulator, representative numbers)

Metric	SQLite (FTS5)	SQLite + Watermelon observer	JS cosine search (Float32Array)	Chroma in FastAPI
Cold open time	35 ms	40 ms	n/a	120 ms (container spin‑up)
Select by PK	1–2 ms	3 ms	n/a	5 ms
MATCH full‑text over 10 k rows	8 ms	10 ms	n/a	7 ms
Top‑k (k=5) cosine search	45 ms (JS loop)	same	18 ms with web‑worker+SIMD (simd.js)	12 ms
Insert 100 recipes	22 ms in txn	28 ms	—	35 ms
DB+index size	11 MB	+1 MB observer	+15 MB embeddings array in RAM	on‑disk 12 MB, RAM ≈40 MB
Image folder (50 kB each)	500 MB	(identical)	(identical)	served via static CDN

Source data: Watermelon and quick‑sqlite benchmark figures  ￼, Chroma memory formula  ￼, HNSW latency doc  ￼, SIMD JS vector blog  ￼.

⸻

5  Tooling stack

Purpose	Backend (Python)	iOS Expo (TS)
Relational store	SQLModel on SQLite (bundled), aiosqlite for async	
Vector DB / search	chromadb ≥0.7 (PersistentClient)  ￼	WASM cosine‑sim via @vladmandic/similarity; fallback to remote /similar
Image processing	Pillow‑SIMD (thumbnail(512), webp quality=80)	
File delivery	fastapi.responses.FileResponse + StreamingResponse	
Bundle zip	Python zipfile (store)	
Download/unpack	expo-file-system + react-native-zip-archive	
SQLite client	expo-sqlite or react-native-quick-sqlite (5× faster)  ￼	
ORM / reactive	WatermelonDB	
Vector search helper	@vladmandic/hnsw (WASM) or simple SIMD cosine loop	
UI libs	React Navigation, React Native Paper, Tailwind‑CSS‑in‑RN	


⸻

6  Step‑by‑step implementation

6.1  Data modelling

# backend/models.py
from sqlmodel import SQLModel, Field, Relationship

class Recipe(SQLModel, table=True):
    id: int = Field(primary_key=True)
    title: str
    instructions_md: str
    category: str
    allergen_json: str   # {"peanut": false, …}

class Ingredient(SQLModel, table=True):
    id: int = Field(primary_key=True)
    recipe_id: int = Field(foreign_key="recipe.id")
    name: str
    amount: str          # "2 tbsp"

PRAGMA foreign_keys=ON;
CREATE VIRTUAL TABLE recipe_search USING fts5(title, instructions_md, content='recipe', content_rowid='id');

Embeddings saved separately as embeddings.npy in the same numeric order as recipe IDs.

6.2  Bundle generator (FastAPI)

@app.post("/bundle/build")
async def build_bundle():
    from zipfile import ZipFile, ZIP_STORED
    ts = datetime.utcnow().strftime("%Y%m%d")
    bundle = Path(f"/tmp/recipes_v{ts}.zip")
    with ZipFile(bundle, "w", ZIP_STORED) as z:
        z.write("data/recipes.db", arcname="recipes.db")
        z.write("data/embeddings.npy", arcname="embeddings.npy")
        for img in Path("data/images").iterdir():
            z.write(img, arcname=f"images/{img.name}")
    return FileResponse(bundle, filename=bundle.name)

6.3  Expo download & init

// hooks/useBundle.ts
import * as FileSystem from 'expo-file-system';
import { unzip } from 'react-native-zip-archive';
const BUNDLE_URL = 'https://api.example.com/bundle/latest';

export async function ensureBundle() {
  const local = FileSystem.documentDirectory + 'recipes';
  await FileSystem.makeDirectoryAsync(local, { intermediates: true });
  const zipPath = local + '/bundle.zip';

  const { uri } = await FileSystem.downloadAsync(BUNDLE_URL, zipPath);
  await unzip(uri, local);             // db, images/, embeddings.npy
}

// db.ts
import * as SQLite from 'expo-sqlite';
export const db = SQLite.openDatabase('recipes.db');

6.4  Local similarity search (Expo)

import { cosineSimilarity } from '@vladmandic/similarity';
import { readAsStringAsync } from 'expo-file-system';

async function loadEmbeddings(): Promise<Float32Array[]> {
  const buf = await FileSystem.readAsStringAsync(
       FileSystem.documentDirectory + 'recipes/embeddings.npy',
       { encoding: FileSystem.EncodingType.Base64 }
  );
  return npyToFloat32Arrays(buf);          // small helper
}

export async function topK(query: Float32Array, k=5) {
  const vecs = await loadEmbeddings();
  const sims = vecs.map(v => cosineSimilarity(v, query));
  return sims
          .map((s, i) => ({ id: i, score: s }))
          .sort((a,b)=>b.score-a.score)
          .slice(0, k);
}

6.5  Backend similarity (fallback)

@app.post("/similar")
def similar(vec: list[float], k:int=5):
    coll = chroma_client.get_collection("recipes")
    ids, dists = coll.query(vector=vec, n_results=k)
    return [ {"id": i, "score": 1-d} for i,d in zip(ids[0], dists[0]) ]

6.6  Offline‑first UX

Moment	Action
App launch	ensureBundle(); if download in progress, use last bundle and show 🔄 icon
Pull‑to‑refresh	Hit /bundle/manifest.json; if newer, start background download
Stale data (TTL expired)	Mark recipe row stale=1; UI shows yellow banner “Might be outdated”


⸻

7  Trade‑offs & recommendation

Criterion	SQLite + FTS5	Chroma‑only	Raw files
Dev effort (iOS)	Low (expo‑sqlite already present)	Need native/WASM port	Simplest
Query power	Structured + text	Vector best, but needs second store for metadata	Poor (manual scans)
RAM @10 k	~5 MB (cache)	40 MB	minimal
Disk	11 MB DB + 0.5 GB images	+ 12 MB index	similar
Offline UX	Excellent	Needs extra RPC if not local	Risky for search
Spoonacular tokens saved	Highest – everything cached	same	same

Final recommendation

Ship the iOS bundle as:
① recipes.db (SQLite + FTS5) for all metadata & queries 
② embeddings.npy loaded into JS‑SIMD cosine search 
③ images/ folder (WebP, 512 px)
FastAPI keeps a Chroma index so future multi‑user or larger datasets can off‑load vector search to the server without changing the client API. This layout minimizes Spoonacular calls to one nightly batch, keeps the app fully offline, and requires only ~550 MB on device while delivering sub‑50 ms interactive queries.


