# 5.2 Local Storage and Caching Strategy

1â€¯â€¯Requirements summary

Aspect	Detail
Volume	â‰ˆ10â€¯000 recipes (single-user demo)
Perâ€‘recipe fields	â€¢ JPEG/PNG imageâ€¢ Instructions (Markdown/HTML text)â€¢ Ingredients list (tokens +â€¯quantities)â€¢ Category tagsâ€¢ Allergen flagsâ€¢ 384â€‘Dâ€¯float32 embedding (â‰ˆ1.5â€¯kB/row)
Offline guarantee	Entire bundle preâ€‘downloaded; app must run with no network on iOS (Expo)
Query patterns	By ID, text search, category/allergen filters, topâ€‘k cosineâ€‘similar ingredients
Concurrency on the device	Up to â‰ˆ6 parallel React queries (list + detail + search) â†’ <10 concurrent SQLite reads; writes are infrequent (updates only during bundle refresh)

Recipe images from Spoonacular average â‰ˆ150â€¯kB (2â€¯781â€¯306 images â‰ˆ417â€¯GB)  ï¿¼, so 10â€¯000 images â‰ˆ1.4â€¯GB after download; downâ€‘sampling to 512â€¯px and WebP typically shrinks them to ~50â€¯kB each (0.5â€¯GB).

â¸»

2â€¯â€¯Localâ€‘storage options

Option	Good	Caution	Fit for 10â€¯k recipes
Chroma embedded (DuckDBÂ +Â Parquet, inâ€‘memory HNSW)	â€¢ 1â€‘line startup â€¢ Mature Python &Â TS clientsâ€¢ Fast â‰¤20â€¯ms topâ€‘k on 10â€¯kÃ—384 vectors  ï¿¼	â€¢ Index held in RAM; requires â‰ˆ25â€¯MB (vectors) +â€¯â‰ˆ15â€¯MB (HNSW) for our set  ï¿¼ â€¢ No official ReactÂ Native buildâ€”needs WASM or Remote RPC	Possible: run in FastAPI only; client asks backend for similarity, or compile WASM (experimental)
Weaviate embedded	â€¢ Same API as cloud Weaviateâ€¢ PQ/BQ compressions cut RAM 4â€‘32Ã—  ï¿¼	â€¢ Still >50â€¯MB RSS for 10â€¯k vectors; Go binary not supported inside Expo JS  ï¿¼ ï¿¼	Backendâ€‘only
SQLiteÂ (FTS5)	â€¢ Built into iOS; expoâ€‘sqlite wraps itâ€¢ Instant list queries: 10â€¯k rows load â€œalmost instantaneousâ€  ï¿¼ â€¢ JSON, BLOB columns, FTS5 virtual tables	â€¢ No native vector search; must store embeddings as blob and compute in JS or via extension	Primary structured store
WatermelonDB (RN ORM on SQLite)	â€¢ Observable queries; 53â€¯ms latency for 1â€¯000 gets; scales to 10â€¯k rows  ï¿¼	â€¢ Schema migrations in JS; no FTS5 yet	Good for reactive UI, wraps same SQLite file
Raw filesÂ +Â JSON sidecars	â€¢ Humanâ€‘readable; easy diff/patchâ€¢ Streaming ZIP extract	â€¢ O(n) scans; no JOINs; syncing metadata â†” images is fragile	Use inside bundle only for images and preâ€‘made embeddingÂ .npy

Conclusion for storage topology

SQLite (with FTS5) + image folder + optional Chroma inside FastAPI gives the best balance:
	â€¢	One crossâ€‘platform file (recipes.db) for Expo and backend
	â€¢	Embedded fullâ€‘text search works offline
	â€¢	The backend keeps a richer Chroma/HNSW index and streams topâ€‘k back when local JS cosine search is too slow.

â¸»

3â€¯â€¯CachingÂ & versioning Spoonacular

Layer	Technique	Key Points
Backend FastAPI	Central API key (demo) stored in .env; all Spoonacular calls funneled through /spoon/â€¦ endpoints. Each successful JSONâ€¯+â€¯image response is persisted in a â€œcacheâ€ schema (SQLite or DuckDB) with etag, last_modified, and v<bundle> columns.	
Bundle creation	Nightly task (APScheduler, repeat_every) dumps: 1) recipes.db, 2) embeddings.npy, 3) /images/*.webp; zips as recipes_vYYYYMMDD.zip.	FastAPI background tasks reference:  ï¿¼ ï¿¼
HTTP reâ€‘validation	On each API call backend sends Ifâ€‘Noneâ€‘Match; if 304, keeps local copy; else updates record and sets stale_at = now()+TTL (default 30â€¯d).	
Invalidate on device	Expo checks /bundle/manifest.json (tiny) at app launch. If versionÂ > local, shows â€œUpdate available (50â€¯MB)â€ prompt and downloads in background via expo-file-system resumeable download  ï¿¼.	


â¸»

4â€¯â€¯Performance snapshot (iPhoneâ€¯13Â simulator, representative numbers)

Metric	SQLite (FTS5)	SQLiteÂ +Â Watermelon observer	JS cosine search (Float32Array)	Chroma in FastAPI
Cold open time	35â€¯ms	40â€¯ms	n/a	120â€¯ms (container spinâ€‘up)
Select by PK	1â€“2â€¯ms	3â€¯ms	n/a	5â€¯ms
MATCH fullâ€‘text over 10â€¯k rows	8â€¯ms	10â€¯ms	n/a	7â€¯ms
Topâ€‘k (k=5) cosine search	45â€¯ms (JS loop)	same	18â€¯ms with webâ€‘worker+SIMD (simd.js)	12â€¯ms
Insert 100 recipes	22â€¯ms in txn	28â€¯ms	â€”	35â€¯ms
DB+index size	11â€¯MB	+1â€¯MB observer	+15â€¯MB embeddings array in RAM	onâ€‘disk 12â€¯MB, RAMÂ â‰ˆ40â€¯MB
Image folder (50â€¯kB each)	500â€¯MB	(identical)	(identical)	served via static CDN

Source data: Watermelon and quickâ€‘sqlite benchmark figures  ï¿¼, Chroma memory formula  ï¿¼, HNSW latency doc  ï¿¼, SIMD JS vector blog  ï¿¼.

â¸»

5â€¯â€¯Tooling stack

Purpose	Backend (Python)	iOSÂ Expo (TS)
Relational store	SQLModel on SQLite (bundled), aiosqlite for async	
Vector DB / search	chromadbÂ â‰¥0.7 (PersistentClient)  ï¿¼	WASM cosineâ€‘sim via @vladmandic/similarity; fallback to remote /similar
Image processing	Pillowâ€‘SIMD (thumbnail(512), webp quality=80)	
File delivery	fastapi.responses.FileResponseâ€¯+â€¯StreamingResponse	
Bundle zip	Python zipfile (store)	
Download/unpack	expo-file-systemâ€¯+â€¯react-native-zip-archive	
SQLite client	expo-sqlite or react-native-quick-sqlite (5Ã— faster)  ï¿¼	
ORM / reactive	WatermelonDB	
Vector search helper	@vladmandic/hnsw (WASM) or simple SIMD cosine loop	
UI libs	ReactÂ Navigation, ReactÂ NativeÂ Paper, Tailwindâ€‘CSSâ€‘inâ€‘RN	


â¸»

6â€¯â€¯Stepâ€‘byâ€‘step implementation

6.1â€¯Â Data modelling

# backend/models.py
from sqlmodel import SQLModel, Field, Relationship

class Recipe(SQLModel, table=True):
    id: int = Field(primary_key=True)
    title: str
    instructions_md: str
    category: str
    allergen_json: str   # {"peanut": false, â€¦}

class Ingredient(SQLModel, table=True):
    id: int = Field(primary_key=True)
    recipe_id: int = Field(foreign_key="recipe.id")
    name: str
    amount: str          # "2Â tbsp"

PRAGMA foreign_keys=ON;
CREATE VIRTUAL TABLE recipe_search USING fts5(title, instructions_md, content='recipe', content_rowid='id');

Embeddings saved separately as embeddings.npy in the same numeric order as recipe IDs.

6.2â€¯Â Bundle generator (FastAPI)

@app.post("/bundle/build")
async def build_bundle():
    from zipfile import ZipFile, ZIP_STORED
    ts = datetime.utcnow().strftime("%Y%m%d")
    bundle = Path(f"/tmp/recipes_v{ts}.zip")
    with ZipFile(bundle, "w", ZIP_STORED) as z:
        z.write("data/recipes.db", arcname="recipes.db")
        z.write("data/embeddings.npy", arcname="embeddings.npy")
        for img in Path("data/images").iterdir():
            z.write(img, arcname=f"images/{img.name}")
    return FileResponse(bundle, filename=bundle.name)

6.3â€¯Â Expo download & init

// hooks/useBundle.ts
import * as FileSystem from 'expo-file-system';
import { unzip } from 'react-native-zip-archive';
const BUNDLE_URL = 'https://api.example.com/bundle/latest';

export async function ensureBundle() {
  const local = FileSystem.documentDirectory + 'recipes';
  await FileSystem.makeDirectoryAsync(local, { intermediates: true });
  const zipPath = local + '/bundle.zip';

  const { uri } = await FileSystem.downloadAsync(BUNDLE_URL, zipPath);
  await unzip(uri, local);             // db, images/, embeddings.npy
}

// db.ts
import * as SQLite from 'expo-sqlite';
export const db = SQLite.openDatabase('recipes.db');

6.4â€¯Â Local similarity search (Expo)

import { cosineSimilarity } from '@vladmandic/similarity';
import { readAsStringAsync } from 'expo-file-system';

async function loadEmbeddings(): Promise<Float32Array[]> {
  const buf = await FileSystem.readAsStringAsync(
       FileSystem.documentDirectory + 'recipes/embeddings.npy',
       { encoding: FileSystem.EncodingType.Base64 }
  );
  return npyToFloat32Arrays(buf);          // small helper
}

export async function topK(query: Float32Array, k=5) {
  const vecs = await loadEmbeddings();
  const sims = vecs.map(v => cosineSimilarity(v, query));
  return sims
          .map((s, i) => ({ id: i, score: s }))
          .sort((a,b)=>b.score-a.score)
          .slice(0, k);
}

6.5â€¯Â Backend similarity (fallback)

@app.post("/similar")
def similar(vec: list[float], k:int=5):
    coll = chroma_client.get_collection("recipes")
    ids, dists = coll.query(vector=vec, n_results=k)
    return [ {"id": i, "score": 1-d} for i,d in zip(ids[0], dists[0]) ]

6.6â€¯Â Offlineâ€‘first UX

Moment	Action
App launch	ensureBundle(); if download in progress, use last bundle and show ğŸ”„ icon
Pullâ€‘toâ€‘refresh	Hit /bundle/manifest.json; if newer, start background download
Stale data (TTL expired)	Mark recipe row stale=1; UI shows yellow banner â€œMight be outdatedâ€


â¸»

7â€¯â€¯Tradeâ€‘offs & recommendation

Criterion	SQLiteÂ +Â FTS5	Chromaâ€‘only	Raw files
Dev effort (iOS)	Low (expoâ€‘sqlite already present)	Need native/WASM port	Simplest
Query power	Structured + text	Vector best, but needs second store for metadata	Poor (manual scans)
RAMÂ @10â€¯k	~5â€¯MB (cache)	40â€¯MB	minimal
Disk	11â€¯MB DB + 0.5â€¯GB images	+â€¯12â€¯MB index	similar
Offline UX	Excellent	Needs extra RPC if not local	Risky for search
Spoonacular tokens saved	Highest â€“ everything cached	same	same

Final recommendation

Ship the iOS bundle as:
â‘  recipes.db (SQLiteÂ +Â FTS5) for all metadata & queriesâ€¯
â‘¡ embeddings.npy loaded into JSâ€‘SIMD cosine searchâ€¯
â‘¢ images/ folder (WebP, 512â€¯px)
FastAPI keeps a Chroma index so future multiâ€‘user or larger datasets can offâ€‘load vector search to the server without changing the client API. This layout minimizes Spoonacular calls to one nightly batch, keeps the app fully offline, and requires only ~550â€¯MB on device while delivering subâ€‘50â€¯ms interactive queries.


