# 5.1 Spoonacular API Usage Analysis

## Executive Summary

PrepSense makes **strategic and efficient** use of the Spoonacular API with comprehensive caching and fallback strategies. The app uses **5 main API endpoints** with smart caching to minimize API calls and costs.

## 🔍 **Spoonacular API Endpoints Used**

### 1. **Recipe Search by Ingredients** (`findByIngredients`)
**Endpoint**: `https://api.spoonacular.com/recipes/findByIngredients`  
**Backend Route**: `POST /recipes/search/by-ingredients`  
**Frontend Trigger**: When user searches recipes with specific ingredients

**Parameters**:
- `ingredients`: Comma-separated ingredient list
- `number`: Number of recipes (default: 10, max: 100)
- `ranking`: 0=maximize used ingredients, 1=minimize missing ingredients
- `ignorePantry`: Whether to ignore typical pantry items
- `intolerances`: Allergen exclusions (dairy, gluten, peanut, etc.)

**Data Volume**: ~10-30 recipes per call

### 2. **Complex Recipe Search** (`complexSearch`)  
**Endpoint**: `https://api.spoonacular.com/recipes/complexSearch`  
**Backend Route**: `POST /recipes/search/complex`  
**Frontend Trigger**: Text-based recipe search with filters

**Parameters**:
- `query`: Natural language search
- `cuisine`, `diet`: Filtering options
- `includeIngredients`/`excludeIngredients`: Ingredient filters
- `intolerances`: Allergen exclusions  
- `maxReadyTime`: Time constraints
- `addRecipeInformation=true`, `fillIngredients=true`: Get detailed data

**Data Volume**: ~10 recipes + full recipe details per call

### 3. **Recipe Information** (`get recipe information`)
**Endpoint**: `https://api.spoonacular.com/recipes/{id}/information`  
**Backend Route**: `GET /recipes/recipe/{recipe_id}`  
**Frontend Trigger**: When user views recipe details

**Parameters**:
- `includeNutrition=true`: Full nutritional data
- Recipe ID from previous searches

**Data Volume**: Complete recipe data (~2-5KB per recipe)

### 4. **Bulk Recipe Information** (`informationBulk`)
**Endpoint**: `https://api.spoonacular.com/recipes/informationBulk`  
**Backend Route**: Internal optimization  
**Usage**: Batch fetch multiple recipes efficiently

**Parameters**:
- `ids`: Comma-separated recipe IDs (up to 100 per call)
- `includeNutrition`: Optional nutrition data

**Data Volume**: 100 recipes per call maximum

### 5. **Random Recipes** (`random`)
**Endpoint**: `https://api.spoonacular.com/recipes/random`  
**Backend Route**: `GET /recipes/random`  
**Frontend Trigger**: Recipe discovery features

**Parameters**:
- `number`: Number of random recipes (1-100)
- `tags`: Optional filtering tags

**Data Volume**: ~10 random recipes per call

### 6. **Parse Ingredients** (`parseIngredients`)
**Endpoint**: `https://api.spoonacular.com/recipes/parseIngredients`  
**Backend Route**: Internal utility  
**Usage**: Ingredient analysis and categorization

**Data Volume**: Ingredient list processing

## 📊 **API Call Frequency Analysis**

### **High-Frequency Calls**
1. **Pantry Recipe Search** - Every time user opens recipes tab (~2-5 calls/day)
2. **Recipe Details** - When user views recipe details (~1-3 calls/session)
3. **Complex Search** - When user searches for specific recipes (~1-2 calls/session)

### **Medium-Frequency Calls**  
1. **Random Recipes** - Recipe discovery (~1 call/day, cached for 30 minutes)
2. **Ingredient Search** - Manual ingredient-based search (~1-2 calls/week)

### **Low-Frequency Calls**
1. **Bulk Information** - Internal optimization (triggered automatically)
2. **Parse Ingredients** - Ingredient analysis (as needed)

## 💾 **Caching & Local Storage Strategy**

### **1. Recipe Cache Service** (`RecipeCacheService`)
**Location**: `backend_gateway/services/recipe_cache_service.py`

**Caching Strategy**:
- **User-specific caching**: Recipes cached per user + pantry state
- **Cache Duration**: 24 hours
- **Smart Refresh**: Tracks shown recipes to avoid repetition
- **Cache Size**: Minimum 40 recipes per user
- **Pantry Hash**: Detects pantry changes to refresh cache

**Cache Keys**:
```
{user_id}_{pantry_hash} → user-specific recipe cache
random_recipes_{number}_{tags} → random recipe cache (30 min TTL)
```

### **2. Database Storage** (`user_recipes` table)
**Purpose**: Store saved/favorite recipes locally
**Data**: Complete recipe JSON + metadata
**Benefits**: Fallback when Spoonacular API fails

**Fallback Strategy**:
```sql
SELECT recipe_data FROM user_recipes 
WHERE recipe_id = ? OR recipe_data->>'id' = ? 
LIMIT 1
```

### **3. Image Caching** 
**Location**: `Recipe Images/` directory
**Pattern**: `recipe_{recipe_id}_*.jpg`
**Fallback**: Local images → Spoonacular CDN

## 🔄 **Live vs Cached Data Usage**

### **Live API Calls**
- ✅ **First pantry search** (cache miss)
- ✅ **Recipe details** (not previously viewed)
- ✅ **New complex searches** 
- ✅ **Pantry changes** (different ingredient hash)

### **Cached Data Usage**
- ✅ **Subsequent pantry searches** (within 24 hours)
- ✅ **Previously viewed recipes** (from database)
- ✅ **Random recipes** (within 30 minutes)
- ✅ **Shown recipe variety** (smart rotation from cache)

## 💰 **Cost Optimization Features**

### **1. Smart Retry Logic**
- **Timeout Handling**: 120s timeout with 60s connect timeout
- **Exponential Backoff**: 1s, 2s, 4s retry delays  
- **Max Retries**: 3 attempts per call
- **Error Classification**: Avoids retries on 500+ server errors

### **2. Batch Processing**
- **Bulk Recipe Info**: Up to 100 recipes per call vs 100 individual calls
- **Ingredient Optimization**: Limits to 5 ingredients to avoid timeouts
- **Recipe Filtering**: Filters insufficient instructions locally

### **3. Request Optimization**
```typescript
// Smart ingredient cleaning to improve search results
search_ingredients = sorted_ingredients[:5]  // Limit to 5 ingredients
cleaned_ingredients = remove_brand_names(ingredients)  // Clean input
```

### **4. Cache-First Strategy**
```typescript
// Check cache before API call
cached_recipes = await cache_service.get_recipe_data(cache_key)
if (cached_recipes) return cached_recipes;
// Only call API if cache miss
```

## 📈 **Data Volume Estimates**

### **Per User Per Day**
- **API Calls**: 3-8 calls
- **Data Transfer**: ~50-200KB  
- **Cached Data**: ~500KB-2MB stored locally

### **Per Recipe**
- **Search Result**: ~1-2KB (basic info)
- **Full Recipe**: ~2-5KB (with nutrition)
- **Bulk Recipe**: ~1-3KB per recipe

## 🔧 **Rate Limiting & Error Handling**

### **Built-in Protections**
- **Request Timeouts**: Prevents hanging requests
- **Retry Logic**: Handles temporary failures
- **Graceful Degradation**: Falls back to cached/saved recipes
- **User Feedback**: Clear error messages for API key issues

### **API Key Management**
```python
# Multiple fallback sources
self.api_key = settings.SPOONACULAR_API_KEY
if not self.api_key:
    with open('config/spoonacular_key.txt', 'r') as f:
        self.api_key = f.read().strip()
```

## 🎯 **Performance Optimizations**

### **1. Local Recipe Fallback**
When Spoonacular API fails, the system automatically checks for locally saved recipe data:
```python
# Fallback to local database
saved_recipe_query = """
    SELECT recipe_data FROM user_recipes
    WHERE recipe_id = %(recipe_id)s
    LIMIT 1
"""
```

### **2. Smart Allergen Filtering** 
- **Client-side pre-filtering**: Checks recipe titles for allergen keywords
- **API-level filtering**: Uses Spoonacular's intolerance parameters
- **Comprehensive mapping**: Maps common allergens to Spoonacular format

### **3. Instruction Quality Control**
```python
# Filters out low-quality recipes
recipes = spoonacular_service.filter_recipes_by_instructions(recipes, min_steps=2)
```

## 📊 **Usage Analytics Dashboard**

The system includes detailed logging for API usage monitoring:
- **Cache Hit/Miss Ratios**: Track caching effectiveness
- **API Call Frequency**: Monitor usage patterns
- **Error Rates**: Track API reliability
- **User Patterns**: Understand feature usage

## 🔒 **Security & Configuration**

### **API Key Security**
- Environment variables (preferred)
- Secure file fallback (`config/spoonacular_key.txt`)
- No hardcoded keys in source code

### **Error Handling**
- Graceful API failures with user-friendly messages
- Fallback to local data when possible
- Clear configuration guidance for users

## 📝 **Recommendations**

### **Current Efficiency**: ⭐⭐⭐⭐⭐ (Excellent)
The current implementation is **highly optimized** with:
- ✅ Comprehensive caching strategy
- ✅ Smart batching and request optimization  
- ✅ Robust error handling and fallbacks
- ✅ Cost-effective API usage patterns

### **Future Enhancements**
1. **Analytics Dashboard**: Track API usage metrics
2. **Predictive Caching**: Pre-cache popular recipes
3. **User Behavior Analytics**: Optimize cache based on usage patterns

---

**Last Updated**: 2025-08-02  
**Analysis Coverage**: Complete Spoonacular API integration  
**Status**: ✅ Comprehensive analysis complete